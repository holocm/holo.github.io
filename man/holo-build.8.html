<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>holo-build(8)</title>
    <link rel="stylesheet" type="text/css" href="/site.css">
</head>
<body>
    <header>
        <div id="header-buttons">
            <a href="https://twitter.com/holocm" title="Follow on Twitter"><span class="logo logo-twitter"></span></a>
            <a href="https://github.com/holocm" title="Fork on GitHub"><span class="logo logo-github"></span></a>
        </div>
        <div id="small-logo">
            <a href="/index.html"><img src="/img/holo-logo.svg"></a>
        </div>
    </header>
    <nav>
        <ul>
            <li><a href="/example.html" class="">Example</a></li>
            <li><a href="/install.html" class="">Installation</a></li>
        </ul>
    </nav>
    <section><h1>NAME</h1><p>holo-build - cross-distribution system package compiler</p><h1>SYNOPSIS</h1><p>holo-build [<em>option</em>...] <em>file</em></p><p>holo-build <strong>--help|--version</strong></p><h1>DESCRIPTION</h1><p>Holo adds a few sprinkles on top of package management to make it suitable for basic configuration management tasks. Its prime directive is to have all configuration statically declared and defined within packages, which can be installed to add new configuration, or uninstalled to remove configuration from a system.</p><p>However, the tools for creating system packages are optimized towards compiling applications for tarballs, and introduce needless complexity when you just want to package up a few files and list some dependencies. holo-build provides a simple, distribution-independent package description language and generates a system package from such a description.</p><p>For example, the following package description will build a package that installs and configures <code>systemd-timesyncd</code> with a custom NTP server:</p><pre><code>    [package]
    name     = &#34;hologram-systemd-timesyncd&#34;
    version  = &#34;1.0&#34;
    author   = &#34;Jane Doe &lt;jane.doe@example.org&gt;&#34;
    requires = [&#34;systemd&#34;]

    [[file]]
    path     = &#34;/etc/systemd/timesyncd.conf.d/server.conf&#34;
    content  = &#34;&#34;&#34;
        [Time]
        NTP=ntp.someserver.local
    &#34;&#34;&#34;

    [[symlink]]
    # as created by `systemctl enable systemd-timesyncd`
    path     = &#34;/etc/systemd/system/sysinit.target.wants/systemd-timesyncd.service&#34;
    target   = &#34;/usr/lib/systemd/system/systemd-timesyncd.service&#34;

    [[action]]
    on     = &#34;setup&#34;
    script = &#34;systemctl daemon-reload &amp;&amp; systemctl start systemd-timesyncd&#34;

    [[action]]
    on     = &#34;cleanup&#34;
    script = &#34;systemctl stop systemd-timesyncd&#34;</code></pre><p>The package description format is described below.</p><h1>OPTIONS</h1><p>The only positional argument <em>file</em> is the file name from where the package definition will be read. If no such argument is given, the package definition is read from standard input instead.</p><span style="color:red">Unknown node type over-text</span><h2>Deprecated options</h2><p>These switches will be removed in the next major version.</p><span style="color:red">Unknown node type over-text</span><h1>PACKAGE DESCRIPTION FORMAT</h1><p>Package descriptions are written in TOML format.</p><p>Only the <code>[package]</code> section is required. All other sections (and all fields not marked as required) are optional.</p><h2><code>[package]</code> section</h2><p>This section is required and contains global properties for the package.</p><pre><code>    [package]
    name    = &#34;example-package&#34;
    version = &#34;1.2.5&#34;
    epoch   = 2
    release = 3
    description = &#34;An example package&#34;
    author      = &#34;Jane Doe &lt;jane.doe@example.org&gt;&#34;
    requires    = [ &#34;other-package &gt;= 2.0&#34; ]
    provides    = [ &#34;example-package-api = 1.2&#34; ]
    conflicts   = [ &#34;bloatware-package&#34; ]
    replaces    = [ &#34;sample-package&#34; ]</code></pre><span style="color:red">Unknown node type over-text</span><h2><code>[[file]]</code> section</h2><p>Each one of these sections define a file to be added to the package.</p><pre><code>    [[file]]
    path    = &#34;/etc/foo.conf&#34;
    mode    = &#34;0600&#34;
    owner   = &#34;foouser&#34;
    group   = &#34;foogroup&#34;
    # alternative 1
    content = &#34;&#34;&#34;
        content for foo.conf
        content for foo.conf
    &#34;&#34;&#34;
    # alternative 2
    contentFrom = &#34;input.txt&#34;</code></pre><span style="color:red">Unknown node type over-text</span><h2><code>[[directory]]</code> section</h2><p>Each one of these sections define a directory to be added to the package.</p><pre><code>    [[directory]]
    path = &#34;/var/lib/foo&#34;
    mode = &#34;0600&#34;
    owner = &#34;foouser&#34;
    group = &#34;foogroup&#34;</code></pre><p>Note that directories are usually created automatically when files are placed in them. A <code>[[directory]]</code> section is only required to include an empty directory in the package, or to assign non-standard permissions or specific ownership to a directory.</p><span style="color:red">Unknown node type over-text</span><h2><code>[[symlink]]</code> section</h2><p>Each one of these sections define a symlink to be added to the package.</p><pre><code>    [[symlink]]
    path   = &#34;/etc/foo.conf&#34;
    target = &#34;bar.conf&#34;</code></pre><span style="color:red">Unknown node type over-text</span><h2><code>[[action]]</code> section</h2><p>Each one of these sections define an action that can be executed by the package manager. For example:</p><pre><code>    [[action]]
    on     = &#34;setup&#34;
    script = &#34;echo Just Installed&#34;</code></pre><span style="color:red">Unknown node type over-text</span><h2><code>[[user]]</code> and <code>[[group]]</code> sections</h2><p>These can be used to provision user accounts and groups when the package is installed. For example:</p><pre><code>    [package]
    name    = &#34;foobar&#34;
    version = &#34;1.0&#34;

    [[group]]
    name   = &#34;foobargroup&#34;
    system = true

    [[user]]
    name   = &#34;foobaruser&#34;
    uid    = 285
    group  = &#34;foobargroup&#34;</code></pre><p>The user and group definitions are validated at package compilation time, and written into <code>/usr/share/holo/users-groups/${package_name}.toml</code>. Because of this file, a dependency on <code>holo-users-groups</code> is implied and <code>holo apply</code> is executed in the setup and cleanup scripts. So the previous example is functionally equivalent to:</p><pre><code>    [package]
    name          = &#34;foobar&#34;
    version       = &#34;1.0&#34;
    depends       = [&#34;holo-users-groups&#34;]

    [[file]]
    path    = &#34;/usr/share/holo/users-groups/foobar.toml&#34;
    content = &#34;&#34;&#34;
        [[group]]
        name   = &#34;foobargroup&#34;
        system = true

        [[user]]
        name   = &#34;foobaruser&#34;
        uid    = 285
        group  = &#34;foobargroup&#34;
    &#34;&#34;&#34;

    [[action]]
    on     = &#34;setup&#34;
    script = &#34;holo apply&#34;

    [[action]]
    on     = &#34;cleanup&#34;
    script = &#34;holo apply&#34;</code></pre><p>The actual syntax and semantics of <code>[[user]]</code> and <code>[[group]]</code> sections is described in <span style="color:red">Unknown node type L</span>.</p></section>
</body>
