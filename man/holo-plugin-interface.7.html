<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>holo-plugin-interface(7)</title>
    <link rel="stylesheet" type="text/css" href="/site.css">
</head>
<body>
    <header>
        <div id="header-buttons">
            <a href="https://twitter.com/holocm" title="Follow on Twitter"><span class="logo logo-twitter"></span></a>
            <a href="https://github.com/holocm" title="Fork on GitHub"><span class="logo logo-github"></span></a>
        </div>
        <div id="small-logo">
            <a href="/index.html"><img src="/img/holo-logo.svg"></a>
        </div>
    </header>
    <nav>
        <ul>
            <li><a href="/example.html" class="">Example</a></li>
            <li><a href="/install.html" class="">Installation</a></li>
        </ul>
    </nav>
    <section><h1>NAME</h1><p>holo-plugin-interface - API specification for Holo plugins</p><h1>DESCRIPTION</h1><p>Holo can leverage plugins to provision previously unknown entity types. For example, given a hypothetical &#34;FooSQL&#34; database, someone could implement a plugin for Holo that provisions FooSQL databases or database users. This document describes the interface that Holo uses to find, invoke, and communicate with its plugins.</p><p>This interface is deliberately designed around classic files and text streams, so that it can easily be implemented even by shell scripts without needing to resort to complex parser libraries.</p><p>This document describes <strong>version 3</strong> of the Holo plugin interface.</p><p>The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in <span style="color:red">Unknown node type L</span>.</p><h2>Plugin discovery</h2><p>Each plugin MUST have an ID following the format <code>[a-z0-9][a-z0-9-]*</code>. When choosing the plugin ID, redundant verbs like <code>manage</code> or <code>provision</code> SHOULD be avoided. A good plugin ID is just the name of the software being configured by the plugin. For example, an appropriate plugin ID for the aforementioned FooSQL plugin would be <code>foosql</code>. The things provisioned MAY be referenced in plural form if disambiguation is required. For example, if FooSQL is configured by multiple plugins, appropriate plugin IDs could include <code>foosql-databases</code> and <code>foosql-users</code>.</p><p>Plugins are not discovered automatically. They MUST be referenced in <code>$HOLO_ROOT_DIR/etc/holorc</code> or <code>$HOLO_ROOT_DIR/etc/holorc.d/*</code> (see <span style="color:red">Unknown node type L</span>) by adding the line in one of the following forms:</p><pre><code>    plugin $PLUGIN_ID
    plugin $PLUGIN_ID=$PLUGIN_BINARY</code></pre><p>If the form without an explicit <code>$PLUGIN_BINARY</code> is given, then Holo will use a default value of</p><pre><code>    PLUGIN_BINARY=/usr/lib/holo/holo-$PLUGIN_ID</code></pre><p>Note that this default value for <code>$PLUGIN_BINARY</code> does NOT respect <code>$HOLO_ROOT_DIR</code>.</p><p>It is RECOMMENDED that plugins install a <span style="color:red">Unknown node type L</span> snippet to achieve this:</p><pre><code>    $ cat $HOLO_ROOT_DIR/etc/holorc.d/50-foosql
    # This file is part of the holo-foosql package.
    plugin foosql</code></pre><p>Old versions of Holo (prior to 1.2) required that the <code>/etc/holorc</code> be modified via <span style="color:red">Unknown node type L</span> through the use of post-install/upgrade/remove scripts. This is no longer required if holorc snippets are used.</p><h1>ENVIRONMENT</h1><p>Plugins SHALL locate and store their data in the directories named by the following environment variables which are set by Holo before executing the plugin:</p><span style="color:red">Unknown node type over-text</span><p>Future versions of Holo may start to choose these paths differently (or allow the user to do so), but the default values are stable and can safely be communicated to users in documentation. Because these paths can be chosen by Holo, plugins SHALL always use the paths in the environment variables rather than trying to compute them by themselves. The paths may or may not be given as absolute paths, so plugins must be careful to handle relative paths correctly if they change directories during operation.</p><h1>EXECUTION</h1><p>The plugin binary is executed one or multiple times when Holo is run, each time with a different operation.</p><h2>The <code>info</code> operation</h2><p>The first invocation is always with the single argument <code>info</code>:</p><pre><code>    $PLUGIN_BINARY info</code></pre><p>The plugin shall then report metadata about itself on stdout, as key-value pairs in the form <code>key=value</code>, with a newline after each value. The following keys are recognized by Holo:</p><span style="color:red">Unknown node type over-text</span><p>All other keys are ignored.</p><h2>The <code>scan</code> operation</h2><p>After <code>info</code> always comes another invocation with the single argument <code>scan</code>:</p><pre><code>    $PLUGIN_BINARY scan</code></pre><p>The plugin shall then scan its <code>$HOLO_RESOURCE_DIR</code> for entities that it can provision. Any errors encountered shall be reported on stderr. If any fatal errors are encountered, the plugin shall exit with non-zero exit code.</p><p>At the end of scanning, the plugin shall provide on stdout a report for each of the entities found, in the following form (this example being from the <code>files</code> plugin from core Holo):</p><pre><code>    ENTITY: file:/etc/locale.gen
    store at: /var/lib/holo/base/etc/locale.gen
    SOURCE: /usr/share/holo/files/00-base/etc/locale.gen
    apply: /usr/share/holo/files/00-base/etc/locale.gen</code></pre><p>Each line has the form <code>key: value</code>. Most lines are informational content that is not processed further by Holo (except for pretty-printing), and can be used to convey any sort of useful information about the entity to the user. However, keys with all capital letters are reserved for special semantics. Currently, the following special keys are known:</p><span style="color:red">Unknown node type over-text</span><p>The report for an entity ends at the next <code>ENTITY: ID</code> line, or when EOF is encountered.</p><p>If scanning for entities is expensive, plugins should cache results of their scanning in <code>$HOLO_CACHE_DIR</code> (as described above).</p><h2>The <code>apply</code> operation</h2><p>If the user requests that one or multiple entities be provisioned (with the <code>holo apply</code> command), then for each of the selected entities, the corresponding plugin will be called like this:</p><pre><code>    $PLUGIN_BINARY apply $ENTITY_ID</code></pre><p>During this operation, the plugin can reuse results from the previously conducted scanning operation if they have been cached in <code>$HOLO_CACHE_DIR</code>. Informational output shall be printed on stdout, errors and warnings shall be printed on stderr. This output will be passed on to the user directly. If an error occurred during provisioning, the plugin shall exit with non-zero exit code.</p><p>During this operation, the plugin process&#39;s file descriptor no. 3 is opened by Holo, and the plugin can write the following messages into this FD to invoke special behavior in Holo:</p><span style="color:red">Unknown node type over-text</span><h2>The <code>force-apply</code> operation</h2><p>During the <code>apply</code> operation, plugins shall refuse to provision entities that appear to have been edited or deleted by the user or an external application. However, when the plugin is called like this:</p><pre><code>    $PLUGIN_BINARY force-apply $ENTITY_ID</code></pre><p>Then the plugin shall overwrite any external changes to the selected entity and bring it into the desired target state with all means possible. Otherwise, the <code>force-apply</code> operation works just like <code>apply</code>.</p><h2>The <code>diff</code> operation</h2><p>If the user requests that a diff be printed for one or multiple entities (with the <code>holo diff</code> command), then for each of the selected entities, the corresponding plugin will be called like this:</p><pre><code>    $PLUGIN_BINARY diff $ENTITY_ID</code></pre><p>If the entity does not have a meaningful diff (e.g. for the <code>run-scripts</code> plugin), the plugin shall exit with zero exit code without doing anything.</p><p>Otherwise, two NUL-terminated filesystem paths must be printed on file descriptor 3. The first file represents the state of the entity as it was last applied by the plugin (i.e., the state the plugin expects it to currently be in), the second file represents the actual current state of the entity.</p><p>The plugin is allowed to return paths that do not exist in the file system, in which case Holo will diff against <code>/dev/null</code> instead. <code>/dev/null</code> can also be given explicitly instead of a file that is missing. (The first file will be missing when the entity is orphaned, and the second file will be missing when the entity was deleted by the user or an external program.)</p><p>For entities that are not backed by a file, the plugin is allowed to make up a useful textual representation of the entity, and write appropriate files to the <code>$HOLO_CACHE_DIR</code>. An example of this is the <code>holo-users-groups</code> plugin.</p><h1>SEE ALSO</h1><p><span style="color:red">Unknown node type L</span>, <span style="color:red">Unknown node type L</span></p><p><span style="color:red">Unknown node type L</span> (test runner for Holo plugins)</p><h1>AUTHOR</h1><p>Stefan Majewsky</p><p>Further documentation is available at the project homepage: https://holocm.org</p><p>Please report any issues and feature requests at GitHub: https://github.com/holocm/holo/issues</p></section>
</body>
